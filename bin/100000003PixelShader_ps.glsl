#if 0
	***	hlms_uv_count0	2
	***	hlms_pose	0
	***	uv_emissive	0
	***	first_valid_detail_map_nm	4
	***	fresnel_scalar	0
	***	envprobe_map_sampler	3
	***	hlms_uv_count	1
	***	pcf_iterations	4
	***	uv_detail_nm1	0
	***	uv_detail_nm2	0
	***	envMapRegSampler	3
	***	emissive_map_sampler	3
	***	hlms_tex_gather	1
	***	precision_mode	-2126167738
	***	BRDF_Default	1
	***	hlms_shadowmap2_array_idx	0
	***	set0_texture_slot_end	3
	***	uv_specular	0
	***	hlms_shadowmap1_uv_min_x_fract	0
	***	hlms_shadowmap2_uv_min_x_fract	50000
	***	hlms_disable_stage	0
	***	NumPoseWeightVectors	0
	***	specular_map_sampler	3
	***	hlms_forwardplus_flipY	1
	***	texcoord	11
	***	glsl	635204550
	***	hlms_shadowmap2_uv_max_y_fract	42857
	***	normal_sampling_format	-1392068498
	***	hlms_shadowmap0_uv_max_x_fract	0
	***	hlms_shadowmap2_uv_max_y_int	0
	***	NumPoseWeightVectorsB	0
	***	hlms_num_shadow_map_lights	3
	***	hlms_lights_directional	1
	***	hlms_shadowmap0_uv_min_y_fract	0
	***	samplerStateStart	3
	***	hlms_shadowmap1_uv_min_y_fract	28571
	***	alpha_test	0
	***	roughness_map_sampler	3
	***	GGX_height_correlated	1
	***	hlms_shadowmap2	0
	***	hlms_shadowmap0_light_idx	0
	***	glsles	1070293233
	***	metallic_workflow	0
	***	hw_gamma_write	1
	***	hlms_shadowmap0_uv_min_y_int	0
	***	uv_detail_weight	0
	***	roughness_map_idx	2
	***	hlms_shadowmap0_uv_max_x_int	1
	***	detail_map_nm2_sampler	3
	***	hlms_shadowmap1_uvs_fulltex	1
	***	hlms_alpha_to_coverage	0
	***	cubemaps_as_diffuse_gi	1
	***	hlms_shadowmap1_uv_max_y_fract	42857
	***	uv_detail_nm3	0
	***	hlms_shadowmap2_uv_max_x_int	1
	***	envmap_scale	1
	***	NumPoseWeightVectorsC	0
	***	hlms_pssm_splits	3
	***	hlms_shadowmap0_uv_min_x_int	0
	***	hlms_pose_normals	0
	***	hlms_pose_half	0
	***	hlms_shadowmap1_light_idx	0
	***	hlms_shadowmap0_uv_min_x_fract	0
	***	hlms_lights_spot	1
	***	shadowmap2_is_directional_light	1
	***	GL_ARB_shading_language_420pack	1
	***	detail_map1_sampler	3
	***	uv_normal	0
	***	relaxed	1726237731
	***	detail_map_nm3_sampler	3
	***	hlms_alphablend	0
	***	textureMaps2	5
	***	hlms_num_shadow_map_textures	1
	***	MoreThanOnePose	-1
	***	hlms_shadowmap1_array_idx	0
	***	num_textures	3
	***	hlslvk	1841745752
	***	hlms_shadowmap1_uv_min_x_int	0
	***	normal_map_tex	2
	***	uv_detail3	0
	***	hlms_shadow_uses_depth_texture	1
	***	ltcMatrix	1
	***	detail_map3_sampler	3
	***	normal_map	1
	***	hlms_shadowmap1	0
	***	needs_env_brdf	1
	***	NumPoseWeightVectorsA	0
	***	hlms_shadowmap2_uv_max_x_fract	0
	***	pcf	3
	***	uv_detail1	0
	***	fresnel_workflow	0
	***	hlms_shadowmap2_uv_min_y_fract	28571
	***	shadowmap1_is_directional_light	1
	***	full32	-2126167738
	***	perceptual_roughness	1
	***	alpha_test_shadow_caster_only	0
	***	materials_per_buffer	240
	***	hw_gamma_read	1
	***	normal_map_tex_idx	1
	***	hlms_skeleton	0
	***	hlms_shadowmap1_uv_max_y_int	0
	***	hlms_pssm_splits_minus_one	2
	***	midf16	-1978079318
	***	hlms_shadowmap2_uv_min_x_int	0
	***	hlms_shadowmap1_uv_max_x_int	0
	***	syntax	-338983575
	***	NeedsMoreThan1BonePerVertex	-1
	***	hlms_lights_point	1
	***	diffuse_map_sampler	3
	***	metal	-1698855755
	***	hlms_fog	1
	***	GL_ARB_base_instance	1
	***	detail_map_nm1_sampler	3
	***	s_lights_directional_non_caster	1
	***	uv_detail0	0
	***	uv_diffuse	0
	***	diffuse_map	1
	***	needs_refl_dir	1
	***	hlms_pssm_blend	1
	***	uv_detail_nm0	0
	***	detail_weight_map_sampler	3
	***	normal_rg_snorm	-1392068498
	***	specular_map	1
	***	GL3+	450
	***	atmosky_npr	3
	***	diffuse_map_idx	0
	***	detail_map_nm0_sampler	3
	***	hlms_shadowmap2_light_idx	0
	***	shadowmap0_is_directional_light	1
	***	hlms_shadowmap0_array_idx	0
	***	hlms_render_depth_only	0
	***	num_pass_const_buffers	4
	***	normal_map_tex_sampler	3
	***	uv_detail2	0
	***	MoreThanOnePoseWeightVector	-1
	***	detail_map2_sampler	3
	***	textureMaps0	3
	***	hlms_shadowmap1_uv_max_x_fract	50000
	***	hlms_shadowmap0_uvs_fulltex	1
	***	detail_map0_sampler	3
	***	hlms_qtangent	1
	***	hlms_shadowmap1_uv_min_y_int	0
	***	uv_roughness	0
	***	roughness_map	3
	***	receive_shadows	1
	***	textureMaps1	4
	***	hlms_pssm_fade	1
	***	clear_coat	0
	***	hlms_shadowmap0	0
	***	needs_view_dir	1
	***	hlms_shadowmap2_uvs_fulltex	1
	***	set1_texture_slot_end	6
	***	use_planar_reflections	0
	***	texShadowMap0	2
	***	hlms_shadowmap2_uv_min_y_int	0
	***	specular_map_idx	0
	***	ambient_hemisphere	1
	***	ltc_texture_available	1
	***	num_samplers	1
	***	glslvk	-338983575
	***	hlms_shadowmap0_uv_max_y_fract	28571
	***	hlsl	-334286542
	***	hlms_shadowmap0_uv_max_y_int	0
	***	normal_weight	0
	***	GL_ARB_texture_buffer_range	1
	DONE DUMPING PROPERTIES
	DONE DUMPING PIECES
#endif


	#version 450 core







	#extension GL_ARB_shading_language_420pack: require
	#define layout_constbuffer(x) layout( std140, x )





	#define bufferFetch texelFetch
	#define structuredBufferFetch texelFetch



	#define min3( a, b, c ) min( a, min( b, c ) )
	#define max3( a, b, c ) max( a, max( b, c ) )


#define float2 vec2
#define float3 vec3
#define float4 vec4

#define int2 ivec2
#define int3 ivec3
#define int4 ivec4

#define uint2 uvec2
#define uint3 uvec3
#define uint4 uvec4

#define float2x2 mat2
#define float3x3 mat3
#define float4x4 mat4
#define ogre_float4x3 mat3x4

#define ushort uint
#define ushort3 uint3
#define ushort4 uint4

//Short used for read operations. It's an int in GLSL & HLSL. An ushort in Metal
#define rshort int
#define rshort2 int2
#define rint int
//Short used for write operations. It's an int in GLSL. An ushort in HLSL & Metal
#define wshort2 int2
#define wshort3 int3

#define toFloat3x3( x ) mat3( x )
#define buildFloat3x3( row0, row1, row2 ) mat3( row0, row1, row2 )

// Let's explain this madness:
//
// We use the keyword "midf" because "half" is already taken on Metal.
//
// When precision_mode == full32 midf is float. Nothing weird
//
// When precision_mode == midf16, midf and midf_c map both to float16_t. It's similar to full32
// but literals need to be prefixed with _h()
//
// Thus, what happens if we resolve some of the macros, we end up with:
//		float16_t a = 1.0f;						// Error
//		float16_t b = _h( 1.0f );				// OK!
//		float16_t c = float16_t( someFloat );	// OK!
//
// But when precision_mode == relaxed; we have the following problem:
//		mediump float a = 1.0f;							// Error
//		mediump float b = _h( 1.0f );					// OK!
//		mediump float c = mediump float( someFloat );	// Invalid syntax!
//
// That's where 'midf_c' comes into play. The "_c" means cast or construct. Hence we do instead:
//		midf c = midf( someFloat );		// Will turn into invalid syntax on relaxed!
//		midf c = midf_c( someFloat );	// OK!
//
// Therefore datatypes are declared with midf. And casts and constructors are with midf_c
// Proper usage is as follows:
//		midf b = _h( 1.0f );
//		midf b = midf_c( someFloat );
//		midf c = midf3_c( 1.0f, 2.0f, 3.0f );
//
// Using this convention ensures that code will compile with all 3 precision modes.
// Breaking this convention means one or more of the modes (except full32) will not compile.

	#define _h(x) (x)

	#define midf float
	#define midf2 vec2
	#define midf3 vec3
	#define midf4 vec4
	#define midf2x2 mat2
	#define midf3x3 mat3
	#define midf4x4 mat4

	#define midf_c float
	#define midf2_c vec2
	#define midf3_c vec3
	#define midf4_c vec4
	#define midf2x2_c mat2
	#define midf3x3_c mat3
	#define midf4x4_c mat4

	#define toMidf3x3( x ) mat3( x )
	#define buildMidf3x3( row0, row1, row2 ) mat3( row0, row1, row2 )

	#define ensureValidRangeF16(x)

	#define saturate(x) clamp( (x), 0.0, 1.0 )




#define mul( x, y ) ((x) * (y))
#define lerp mix
#define rsqrt inversesqrt
#define INLINE
#define NO_INTERPOLATION_PREFIX flat
#define NO_INTERPOLATION_SUFFIX

#define PARAMS_ARG_DECL
#define PARAMS_ARG


	#define inVs_vertexId gl_VertexIndex

#define inVs_vertex vertex
#define inVs_normal normal
#define inVs_tangent tangent
#define inVs_binormal binormal
#define inVs_blendWeights blendWeights
#define inVs_blendIndices blendIndices
#define inVs_qtangent qtangent
#define inVs_colour colour


	#define inVs_drawId drawId


#define finalDrawId inVs_drawId


	#define inVs_uv0 uv0

#define outVs_Position gl_Position
#define outVs_viewportIndex gl_ViewportIndex
#define outVs_clipDistance0 gl_ClipDistance[0]

#define gl_SampleMaskIn0 gl_SampleMaskIn[0]
#define reversebits bitfieldReverse

#define outPs_colour0 outColour


	#define OGRE_SampleArray2D( tex, sampler, uv, arrayIdx ) texture( sampler2DArray( tex, sampler ), vec3( uv, arrayIdx ) )
	#define OGRE_SampleArray2DLevel( tex, sampler, uv, arrayIdx, lod ) textureLod( sampler2DArray( tex, sampler ), vec3( uv, arrayIdx ), lod )
	#define OGRE_SampleArrayCubeLevel( tex, sampler, uv, arrayIdx, lod ) textureLod( samplerCubeArray( tex, sampler ), vec4( uv, arrayIdx ), lod )
	#define OGRE_SampleArray2DGrad( tex, sampler, uv, arrayIdx, ddx, ddy ) textureGrad( sampler2DArray( tex, sampler ), vec3( uv, arrayIdx ), ddx, ddy )

	#define OGRE_Load2DF16( tex, iuv, lod ) midf4_c( texelFetch( tex, ivec2( iuv ), lod ) )
	#define OGRE_Load2DMSF16( tex, iuv, subsample ) midf4_c( texelFetch( tex, iuv, subsample ) )
	#define OGRE_SampleArray2DF16( tex, sampler, uv, arrayIdx ) midf4_c( texture( sampler2DArray( tex, sampler ), vec3( uv, arrayIdx ) ) )
	#define OGRE_SampleArray2DLevelF16( tex, sampler, uv, arrayIdx, lod ) midf4_c( textureLod( sampler2DArray( tex, sampler ), vec3( uv, arrayIdx ), lod ) )
	#define OGRE_SampleArrayCubeLevelF16( tex, sampler, uv, arrayIdx, lod ) midf4_c( textureLod( samplerCubeArray( tex, sampler ), vec4( uv, arrayIdx ), lod ) )
	#define OGRE_SampleArray2DGradF16( tex, sampler, uv, arrayIdx, ddx, ddy ) midf4_c( textureGrad( sampler2DArray( tex, sampler ), vec3( uv, arrayIdx ), ddx, ddy ) )

	float4 OGRE_Sample( texture2D t, sampler s, float2 uv ) { return texture( sampler2D( t, s ), uv ); }
	float4 OGRE_Sample( texture3D t, sampler s, float3 uv ) { return texture( sampler3D( t, s ), uv ); }
	float4 OGRE_Sample( textureCube t, sampler s, float3 uv ) { return texture( samplerCube( t, s ), uv ); }

	float4 OGRE_SampleLevel( texture2D t, sampler s, float2 uv, float lod ) { return textureLod( sampler2D( t, s ), uv, lod ); }
	float4 OGRE_SampleLevel( texture3D t, sampler s, float3 uv, float lod ) { return textureLod( sampler3D( t, s ), uv, lod ); }
	float4 OGRE_SampleLevel( textureCube t, sampler s, float3 uv, float lod ) { return textureLod( samplerCube( t, s ), uv, lod ); }

	float4 OGRE_SampleGrad( texture2D t, sampler s, float2 uv, float2 myDdx, float2 myDdy ) { return textureGrad( sampler2D( t, s ), uv, myDdx, myDdy ); }
	float4 OGRE_SampleGrad( texture3D t, sampler s, float3 uv, float3 myDdx, float3 myDdy ) { return textureGrad( sampler3D( t, s ), uv, myDdx, myDdy ); }
	float4 OGRE_SampleGrad( textureCube t, sampler s, float3 uv, float3 myDdx, float3 myDdy ) { return textureGrad( samplerCube( t, s ), uv, myDdx, myDdy ); }

	midf4 OGRE_SampleF16( texture2D t, sampler s, float2 uv ) { return midf4_c( texture( sampler2D( t, s ), uv ) ); }
	midf4 OGRE_SampleF16( texture3D t, sampler s, float3 uv ) { return midf4_c( texture( sampler3D( t, s ), uv ) ); }
	midf4 OGRE_SampleF16( textureCube t, sampler s, float3 uv ) { return midf4_c( texture( samplerCube( t, s ), uv ) ); }

	midf4 OGRE_SampleLevelF16( texture2D t, sampler s, float2 uv, float lod ) { return midf4_c( textureLod( sampler2D( t, s ), uv, lod ) ); }
	midf4 OGRE_SampleLevelF16( texture3D t, sampler s, float3 uv, float lod ) { return midf4_c( textureLod( sampler3D( t, s ), uv, lod ) ); }
	midf4 OGRE_SampleLevelF16( textureCube t, sampler s, float3 uv, float lod ) { return midf4_c( textureLod( samplerCube( t, s ), uv, lod ) ); }

	midf4 OGRE_SampleGradF16( texture2D t, sampler s, float2 uv, float2 myDdx, float2 myDdy ) { return midf4_c( textureGrad( sampler2D( t, s ), uv, myDdx, myDdy ) ); }
	midf4 OGRE_SampleGradF16( texture3D t, sampler s, float3 uv, float3 myDdx, float3 myDdy ) { return midf4_c( textureGrad( sampler3D( t, s ), uv, myDdx, myDdy ) ); }
	midf4 OGRE_SampleGradF16( textureCube t, sampler s, float3 uv, float3 myDdx, float3 myDdy ) { return midf4_c( textureGrad( samplerCube( t, s ), uv, myDdx, myDdy ) ); }

#define OGRE_ddx( val ) dFdx( val )
#define OGRE_ddy( val ) dFdy( val )
#define OGRE_Load2D( tex, iuv, lod ) texelFetch( tex, ivec2( iuv ), lod )
#define OGRE_LoadArray2D( tex, iuv, arrayIdx, lod ) texelFetch( tex, ivec3( iuv, arrayIdx ), lod )
#define OGRE_Load2DMS( tex, iuv, subsample ) texelFetch( tex, iuv, subsample )

#define OGRE_Load3D( tex, iuv, lod ) texelFetch( tex, ivec3( iuv ), lod )

#define bufferFetch1( buffer, idx ) texelFetch( buffer, idx ).x


	#define OGRE_SAMPLER_ARG_DECL( samplerName ) , sampler samplerName
	#define OGRE_SAMPLER_ARG( samplerName ) , samplerName

	#define CONST_BUFFER( bufferName, bindingPoint ) layout_constbuffer(ogre_B##bindingPoint) uniform bufferName
	#define CONST_BUFFER_STRUCT_BEGIN( structName, bindingPoint ) layout_constbuffer(ogre_B##bindingPoint) uniform structName
	#define CONST_BUFFER_STRUCT_END( variableName ) variableName

	#define ReadOnlyBufferF( slot, varType, varName ) layout(std430, ogre_R##slot) readonly restrict buffer _##varName { varType varName[]; }
	#define ReadOnlyBufferU ReadOnlyBufferF
	#define readOnlyFetch( bufferVar, idx ) bufferVar[idx]
	#define readOnlyFetch1( bufferVar, idx ) bufferVar[idx]



#define OGRE_Texture3D_float4 texture3D

#define OGRE_ArrayTex( declType, varName, arrayCount ) declType varName[arrayCount]

#define FLAT_INTERPOLANT( decl, bindingPoint ) flat decl
#define INTERPOLANT( decl, bindingPoint ) decl

#define OGRE_OUT_REF( declType, variableName ) out declType variableName
#define OGRE_INOUT_REF( declType, variableName ) inout declType variableName

#define OGRE_ARRAY_START( type ) type[](
#define OGRE_ARRAY_END )




	#define UV_DIFFUSE(x) (x)
	#define UV_NORMAL(x) (x)
	#define UV_SPECULAR(x) (x)
	#define UV_ROUGHNESS(x) (x)
	#define UV_DETAIL_WEIGHT(x) (x)
	#define UV_DETAIL0(x) (x)
	#define UV_DETAIL1(x) (x)
	#define UV_DETAIL2(x) (x)
	#define UV_DETAIL3(x) (x)
	#define UV_DETAIL_NM0(x) (x)
	#define UV_DETAIL_NM1(x) (x)
	#define UV_DETAIL_NM2(x) (x)
	#define UV_DETAIL_NM3(x) (x)
	#define UV_EMISSIVE(x) (x)
	


layout(std140) uniform;


	
		
			layout(location = 0, index = 0) out midf4 outColour;
		
		
		
	













	// START UNIFORM DECLARATION
	
		
			
struct ShadowReceiverData
{
	float4x4 texViewProj;

	float2 shadowDepthRange;
	float normalOffsetBias;
	float padding;
	float4 invShadowMapSize;
};

struct Light
{
	
		float4 position;	//.w contains the objLightMask
	
	float4 diffuse;		//.w contains numNonCasterDirectionalLights
	float3 specular;

	float3 attenuation;
	//Spotlights:
	//  spotDirection.xyz is direction
	//  spotParams.xyz contains falloff params
	float4 spotDirection;
	float4 spotParams;


#define lightTexProfileIdx spotDirection.w
};

#define numNonCasterDirectionalLights lights[0].diffuse.w

#define areaLightDiffuseMipmapStart areaApproxLights[0].diffuse.w
#define areaLightNumMipmapsSpecFactor areaApproxLights[0].specular.w

#define numAreaApproxLights areaApproxLights[0].doubleSided.y
#define numAreaApproxLightsWithMask areaApproxLights[0].doubleSided.z

#define numAreaLtcLights areaLtcLights[0].points[0].w
#define numAreaLtcLights areaLtcLights[0].points[0].w

struct AreaLight
{
	
		float4 position;	//.w contains the objLightMask
	
	float4 diffuse;		//[0].w contains diffuse mipmap start
	float4 specular;	//[0].w contains mipmap scale
	float4 attenuation;	//.w contains texture array idx
	//Custom 2D Shape:
	//  direction.xyz direction
	//  direction.w invHalfRectSize.x
	//  tangent.xyz tangent
	//  tangent.w invHalfRectSize.y
	float4 direction;
	float4 tangent;
	float4 doubleSided;	//.y contains numAreaApproxLights
						//.z contains numAreaApproxLightsWithMask
	
};

struct AreaLtcLight
{
	
		float4 position;	//.w contains the objLightMask
	
	float4 diffuse;			//.w contains attenuation range
	float4 specular;		//.w contains doubleSided
	float4 points[4];		//.w contains numAreaLtcLights
							//points[1].w, points[2].w, points[3].w contain obbFadeFactorLtc.xyz
	
};





//Uniforms that change per pass
CONST_BUFFER_STRUCT_BEGIN( PassBuffer, 0 )
{
	//Vertex shader (common to both receiver and casters)

	float4x4 viewProj;







	//Vertex shader
	float4x4 view;
	ShadowReceiverData shadowRcv[3];

	

	//-------------------------------------------------------------------------

	//Pixel shader
	float3x3 invViewMatCubemap;


	float4 pccVctMinDistance_invPccVctInvDistance_rightEyePixelStartX_envMapNumMipmaps;

	float4 aspectRatio_planarReflNumMips_unused2;

	float2 invWindowRes;
	float2 windowResolution;


	float4 ambientUpperHemi;


	float4 ambientLowerHemi;
	float4 ambientHemisphereDir;







	float pssmSplitPoints0;
	float pssmSplitPoints1;
	float pssmSplitPoints2;

	float pssmBlendPoints0;
	float pssmBlendPoints1;

	float pssmFadePoint;



	Light lights[1];
	
	
// !use_light_buffers





	



	
	

	

#define pccVctMinDistance		pccVctMinDistance_invPccVctInvDistance_rightEyePixelStartX_envMapNumMipmaps.x
#define invPccVctInvDistance	pccVctMinDistance_invPccVctInvDistance_rightEyePixelStartX_envMapNumMipmaps.y
#define rightEyePixelStartX		pccVctMinDistance_invPccVctInvDistance_rightEyePixelStartX_envMapNumMipmaps.z
#define envMapNumMipmaps		pccVctMinDistance_invPccVctInvDistance_rightEyePixelStartX_envMapNumMipmaps.w

#define aspectRatio			aspectRatio_planarReflNumMips_unused2.x
#define planarReflNumMips	aspectRatio_planarReflNumMips_unused2.y
}
CONST_BUFFER_STRUCT_END( passBuf );



#define light0Buf		passBuf
#define light1Buf		passBuf
#define light2Buf		passBuf

// use_light_buffers


		
		
//Uniforms that change per Item/Entity, but change very infrequently
struct Material
{
	/* kD is already divided by PI to make it energy conserving.
	  (formula is finalDiffuse = NdotL * surfaceDiffuse / PI)
	*/
	float4 bgDiffuse;
	float4 kD; //kD.w is alpha_test_threshold
	float4 kS; //kS.w is roughness
	//Fresnel coefficient, may be per colour component (float3) or scalar (float)
	//F0.w is transparency
	float4 F0;
	float4 normalWeights;
	float4 cDetailWeights;
	float4 detailOffsetScale[4];
	float4 emissive;		//emissive.w contains mNormalMapWeight.
	float refractionStrength;
	float clearCoat;
	float clearCoatRoughness;
	float _padding1;
	float4 userValue[3];

	
		uint4 indices0_3;
		uint4 indices4_7;
	

	
};
	

	
		CONST_BUFFER( MaterialBuf, 1 )
		{
			Material materialArray[240];
		};
	

		
		//Uniforms that change per Item/Entity
		CONST_BUFFER( InstanceBuffer, 2 )
		{
			//.x =
			//The lower 9 bits contain the material's start index.
			//The higher 23 bits contain the world matrix start index.
			//
			//.y =
			//shadowConstantBias. Send the bias directly to avoid an
			//unnecessary indirection during the shadow mapping pass.
			//Must be loaded with uintBitsToFloat
			//
			//.z =
			//lightMask. Ogre must have been compiled with OGRE_NO_FINE_LIGHT_MASK_GRANULARITY
			
				uint4 worldMaterialIdx[4096];
			
		};
	
		
	struct AtmoSettings
	{
		float densityCoeff;
		float lightDensity;
		float sunHeight;
		float sunHeightWeight;

		float4 skyLightAbsorption;
		float4 sunAbsorption;
		float4 cameraDisplacement;
		float4 packedParams1;
		float4 packedParams2;
		float4 packedParams3;

		float fogDensity;
		float fogBreakMinBrightness;
		float fogBreakFalloff;
		float padding0;
	};

	
		CONST_BUFFER( AtmoSettingsBuf, 3 )
		{
			AtmoSettings atmoSettings;
		};
	

	
	
	// END UNIFORM DECLARATION

	
		#define float_fresnel midf
		#define float_fresnel_c( x ) midf_c( x )
		#define make_float_fresnel( x ) midf_c( x )
	

	
	
		#define OGRE_DEPTH_CMP_GE( a, b ) (a) <= (b)
		#define OGRE_DEPTH_DEFAULT_CLEAR 0.0
	


	
		#define PASSBUF_ARG_DECL
		#define PASSBUF_ARG
	

	

	struct PixelData
	{
		
			midf3 normal;
			
				midf3 geomNormal;
			
			midf4	diffuse;
			midf3	specular;

			

			midf	perceptualRoughness;
			midf	roughness;
			float_fresnel	F0;

			
				midf3	viewDir;
				midf	NdotV;
			

			
				midf3 reflDir;
				
					midf3 envColourS;
					midf3 envColourD;

					
				
			
		

		
	};

	#define SampleDetailWeightMap( tex, sampler, uv, arrayIdx ) OGRE_SampleArray2DF16( tex, sampler, uv, arrayIdx )
	
	
		#define SampleDiffuse( tex, sampler, uv, arrayIdx ) OGRE_SampleArray2DF16( tex, sampler, uv, arrayIdx ) 
	
	
		#define SampleSpecular( tex, sampler, uv, arrayIdx ) OGRE_SampleArray2DF16( tex, sampler, uv, arrayIdx )
	
	
		#define SampleRoughness( tex, sampler, uv, arrayIdx ) OGRE_SampleArray2DF16( tex, sampler, uv, arrayIdx )
	
	
	

	

	
		INLINE midf3 reconstructZfromTSNormal( midf2 tsNormal2 )
		{
			midf3 tsNormal;
			tsNormal.xy = tsNormal2.xy;
			tsNormal.z	= sqrt( max( _h(0.0f), _h(1.0f) - tsNormal.x * tsNormal.x - tsNormal.y * tsNormal.y ) );
			return tsNormal.xyz;
		}

		
			//Normal texture must be in UV8/RG8_SNORM or BC5S format!
			#define getTSNormal( normalMap, samplerState, uv, normalIdx ) reconstructZfromTSNormal( OGRE_SampleArray2DF16( normalMap, samplerState, uv, normalIdx ).xy )
		
		
		
		
	

	

	
		

		
//Default BRDF
INLINE midf3 BRDF( midf3 lightDir, midf3 lightDiffuse, midf3 lightSpecular, PixelData pixelData )
{
	midf3 halfWay = normalize( lightDir + pixelData.viewDir );
	midf NdotL = saturate( dot( pixelData.normal, lightDir ) );
	midf NdotH = saturate( dot( pixelData.normal, halfWay ) );
	midf VdotH = saturate( dot( pixelData.viewDir, halfWay ) );

	midf sqR = pixelData.roughness * pixelData.roughness;

	//Geometric/Visibility term (Smith GGX Height-Correlated)

	midf Lambda_GGXV = NdotL * sqrt( (-pixelData.NdotV * sqR + pixelData.NdotV) * pixelData.NdotV + sqR );
	midf Lambda_GGXL = pixelData.NdotV * sqrt( (-NdotL * sqR + NdotL) * NdotL + sqR );

	midf G = _h( 0.5 ) / (( Lambda_GGXV + Lambda_GGXL + _h( 1e-6f ) ) * _h( 3.141592654 ));



	//Roughness/Distribution/NDF term (GGX)
	//Formula:
	//	Where alpha = roughness
	//	R = alpha^2 / [ PI * [ ( NdotH^2 * (alpha^2 - 1) ) + 1 ]^2 ]
	const midf f = ( NdotH * sqR - NdotH ) * NdotH + _h( 1.0 );
	midf R = sqR / (f * f); // f is guaranteed to not be 0 because we clamped pixelData.roughness

	const midf RG = R * G;


	//Formula:
	//	fresnelS = lerp( (1 - V*H)^5, 1, F0 )
    float_fresnel fresnelS = pixelData.F0 + pow( _h( 1.0 ) - VdotH, _h( 5.0 ) ) * (_h( 1.0 ) - pixelData.F0);

	//We should divide Rs by PI, but it was done inside G for performance
	midf3 Rs = ( fresnelS * RG ) * pixelData.specular.xyz;

	//Diffuse BRDF (*Normalized* Disney, see course_notes_moving_frostbite_to_pbr.pdf
	//"Moving Frostbite to Physically Based Rendering" Sebastien Lagarde & Charles de Rousiers)
	midf energyBias	= pixelData.perceptualRoughness * _h( 0.5 );
	midf energyFactor	= lerp( _h( 1.0 ), _h( 1.0 / 1.51 ), pixelData.perceptualRoughness );
	midf fd90			= energyBias + _h( 2.0 ) * VdotH * VdotH * pixelData.perceptualRoughness;
	midf lightScatter	= _h( 1.0 ) + (fd90 - _h( 1.0 )) * pow( _h( 1.0 ) - NdotL, _h( 5.0 ) );
	midf viewScatter	= _h( 1.0 ) + (fd90 - _h( 1.0 )) * pow( _h( 1.0 ) - pixelData.NdotV, _h( 5.0 ) );

    
		midf fresnelD = _h( 1.0f ) - fresnelS;
    

	//We should divide Rd by PI, but it is already included in kD
	midf3 Rd = (lightScatter * viewScatter * energyFactor * fresnelD) * pixelData.diffuse.xyz;

	
		return NdotL * (Rs * lightSpecular + Rd * lightDiffuse);
	
}

		
		
	

	
	
	
	
	






vulkan_layout( location = 0 ) in block
{

	
		
			FLAT_INTERPOLANT( ushort drawId, 0 );
		
	

	
		
			INTERPOLANT( float3 pos, 1 );
			INTERPOLANT( midf3 normal, 2 );
			
				INTERPOLANT( midf3 tangent, 3 );
				FLAT_INTERPOLANT( midf biNormalReflection, 4 );
			
		
		
			INTERPOLANT( float2 uv0, 5 );

		
			
				
					INTERPOLANT( float4 posL0, 6 );
				
			
				
					INTERPOLANT( float4 posL1, 7 );
				
			
				
					INTERPOLANT( float4 posL2, 8 );
				
			
		

		INTERPOLANT( float depth, 9 );
		

		

		
			// fog.xyz = colour
			INTERPOLANT( midf3 fog, 10 );
		
	
	

} inPs;










	vulkan_layout( ogre_t3 ) uniform texture2DArray textureMaps0;
	vulkan_layout( ogre_t4 ) uniform texture2DArray textureMaps1;
	vulkan_layout( ogre_t5 ) uniform texture2DArray textureMaps2;




	
		layout( ogre_s3 ) uniform sampler samplerState3;











	#define hlms_shadowmap0 texShadowMap0
	#define hlms_shadowmap0_uv_min float2( 0.0, 0.0 )
	#define hlms_shadowmap0_uv_max float2( 1.0, 0.28571 )
	
		
		
			#define hlms_shadowmap0_uv_param , hlms_shadowmap0_uv_min, hlms_shadowmap0_uv_max
		
	

	#define hlms_shadowmap1 texShadowMap0
	#define hlms_shadowmap1_uv_min float2( 0.0, 0.28571 )
	#define hlms_shadowmap1_uv_max float2( 0.50000, 0.42857 )
	
		
		
			#define hlms_shadowmap1_uv_param , hlms_shadowmap1_uv_min, hlms_shadowmap1_uv_max
		
	

	#define hlms_shadowmap2 texShadowMap0
	#define hlms_shadowmap2_uv_min float2( 0.50000, 0.28571 )
	#define hlms_shadowmap2_uv_max float2( 1.0, 0.42857 )
	
		
		
			#define hlms_shadowmap2_uv_param , hlms_shadowmap2_uv_min, hlms_shadowmap2_uv_max
		
	





	#define OGRE_SAMPLE_SHADOW( tex, sampler, uv, depth ) (OGRE_DEPTH_CMP_GE( depth, OGRE_DEPTH_DEFAULT_CLEAR ) ? _h( 1.0 ) : midf_c( texture( sampler2DShadow( tex, sampler ), vec3( uv, depth ) ) ) )
	#define OGRE_SAMPLE_SHADOW_ESM( tex, sampler, uv ) textureLod( sampler2D( tex, sampler ), uv, 0 ).x







		layout( ogre_s2 ) uniform samplerShadow shadowSampler;
		
			layout( ogre_t2 ) uniform texture2D texShadowMap0;
	


	
		
			
				#define inPs_posL0 inPs.posL0
			
		
			
				#define inPs_posL1 inPs.posL1
			
		
			
				#define inPs_posL2 inPs.posL2
			
		
	

	
		// Perform normal offset bias. See https://github.com/OGRECave/ogre-next/issues/100
		INLINE float3 getNormalOffsetBiasPoint( midf3 geomNormal, float3 lightDir,
												float normalOffsetBias, float shadowMapTexSize,
												float depthRange
		
												)
		
		{
			float tmpNdotL = saturate( dot( lightDir.xyz, float3( geomNormal.xyz ) ) );

			

			return ( ( 1.0f - tmpNdotL ) * normalOffsetBias * float3( geomNormal.xyz ) * shadowMapTexSize );
		}
	
		// Perform normal offset bias. See https://github.com/OGRECave/ogre-next/issues/100
		INLINE float3 getNormalOffsetBiasPoint( midf3 geomNormal, float3 lightDir,
												float normalOffsetBias, float shadowMapTexSize,
												float depthRange
		
												, float2 minUV, float2 maxUV )
		
		{
			float tmpNdotL = saturate( dot( lightDir.xyz, float3( geomNormal.xyz ) ) );

			
				shadowMapTexSize /= maxUV.x - minUV.x;
			

			return ( ( 1.0f - tmpNdotL ) * normalOffsetBias * float3( geomNormal.xyz ) * shadowMapTexSize );
		}
	

	
		INLINE midf getShadow( texture2D shadowMap, samplerShadow shadowSampler, 
								float4 psPosLN, float4 invShadowMapSize )
	
	{
	
		//Spot and directional lights
		
			float fDepth = psPosLN.z / psPosLN.w;
		
		float2 uv = float2( psPosLN.xy / psPosLN.w );
	

	
		midf retVal = _h( 0. );

		
			float2 offsets[4] =
			
				float2[4](
			
			
				float2( 0., 0. ),	//0, 0
				float2( 1., 0. ),	//1, 0
				float2( 0., 1. ),	//1, 1
				float2(-1., 0. ) 	//0, 1
			
			
			
			
			
			);
			
		

		
		
			
				uv += offsets[0] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[1] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[2] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[3] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
		

		
			retVal *= _h( 0.25 );
		
	///! exponential_shadow_maps
	   ///! exponential_shadow_maps

	

	

		return retVal;
	}

	
		INLINE midf getShadow( texture2D shadowMap, samplerShadow shadowSampler, 
								float4 psPosLN, float4 invShadowMapSize, float2 minUV, float2 maxUV )
	
	{
	
		//Spot and directional lights
		
			float fDepth = psPosLN.z / psPosLN.w;
		
		float2 uv = float2( psPosLN.xy / psPosLN.w );
	

	
		midf retVal = _h( 0. );

		
			float2 offsets[4] =
			
				float2[4](
			
			
				float2( 0., 0. ),	//0, 0
				float2( 1., 0. ),	//1, 0
				float2( 0., 1. ),	//1, 1
				float2(-1., 0. ) 	//0, 1
			
			
			
			
			
			);
			
		

		
		
			
				uv += offsets[0] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[1] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[2] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[3] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
		

		
			retVal *= _h( 0.25 );
		
	///! exponential_shadow_maps
	   ///! exponential_shadow_maps

	

	
		retVal = (uv.x <= minUV.x || uv.x >= maxUV.x ||
				  uv.y <= minUV.y || uv.y >= maxUV.y) ? _h( 1.0 ) : retVal;
	

		return retVal;
	}

	
		INLINE midf getShadowPoint( texture2D shadowMap, samplerShadow shadowSampler, 
									 midf3 geomNormal, float normalOffsetBias,
									 float3 posVS, float3 lightPos,float4 invShadowMapSize, float2 invDepthRange
									 PASSBUF_ARG_DECL )
	
	{
	
		//Point lights
		float3 cubemapDir = posVS.xyz - lightPos.xyz;
		cubemapDir += getNormalOffsetBiasPoint( geomNormal, cubemapDir, normalOffsetBias,
				
												invShadowMapSize.x, invDepthRange.y );
				

		float fDepth = length( cubemapDir );
		cubemapDir *= 1.0 / fDepth;
		cubemapDir = mul( cubemapDir.xyz, passBuf.invViewMatCubemap );
		
			fDepth = (invDepthRange.x - fDepth) * invDepthRange.y;
		

		float2 uv;
		uv.x = (cubemapDir.x / (1.0 + abs( cubemapDir.z ))) * 0.25 +
				(cubemapDir.z < 0.0 ? 0.75 : 0.25 );
		uv.y = (cubemapDir.y / (1.0 + abs( cubemapDir.z ))) * 0.5 + 0.5;

		
	

	
		midf retVal = _h( 0. );

		
			float2 offsets[4] =
			
				float2[4](
			
			
				float2( 0., 0. ),	//0, 0
				float2( 1., 0. ),	//1, 0
				float2( 0., 1. ),	//1, 1
				float2(-1., 0. ) 	//0, 1
			
			
			
			
			
			);
			
		

		
		
			
				uv += offsets[0] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[1] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[2] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[3] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
		

		
			retVal *= _h( 0.25 );
		
	///! exponential_shadow_maps
	   ///! exponential_shadow_maps

	

	

		return retVal;
	}

	
		INLINE midf getShadowPoint( texture2D shadowMap, samplerShadow shadowSampler, 
									 midf3 geomNormal, float normalOffsetBias,
									 float3 posVS, float3 lightPos, float4 invShadowMapSize, float2 invDepthRange,
									 float2 minUV, float2 maxUV, float2 lengthUV
									 PASSBUF_ARG_DECL )
	
	{
	
		//Point lights
		float3 cubemapDir = posVS.xyz - lightPos.xyz;
		cubemapDir += getNormalOffsetBiasPoint( geomNormal, cubemapDir, normalOffsetBias,
				
												invShadowMapSize.x, invDepthRange.y, minUV, maxUV );
				

		float fDepth = length( cubemapDir );
		cubemapDir *= 1.0 / fDepth;
		cubemapDir = mul( cubemapDir.xyz, passBuf.invViewMatCubemap );
		
			fDepth = (invDepthRange.x - fDepth) * invDepthRange.y;
		

		float2 uv;
		uv.x = (cubemapDir.x / (1.0 + abs( cubemapDir.z ))) * 0.25 +
				(cubemapDir.z < 0.0 ? 0.75 : 0.25 );
		uv.y = (cubemapDir.y / (1.0 + abs( cubemapDir.z ))) * 0.5 + 0.5;

		uv.xy = uv.xy * lengthUV.xy + minUV.xy;
	

	
		midf retVal = _h( 0. );

		
			float2 offsets[4] =
			
				float2[4](
			
			
				float2( 0., 0. ),	//0, 0
				float2( 1., 0. ),	//1, 0
				float2( 0., 1. ),	//1, 1
				float2(-1., 0. ) 	//0, 1
			
			
			
			
			
			);
			
		

		
		
			
				uv += offsets[0] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[1] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[2] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[3] * invShadowMapSize.xy;
				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
		

		
			retVal *= _h( 0.25 );
		
	///! exponential_shadow_maps
	   ///! exponential_shadow_maps

	

	
		retVal = (uv.x <= minUV.x || uv.x >= maxUV.x ||
				  uv.y <= minUV.y || uv.y >= maxUV.y) ? _h( 1.0 ) : retVal;
	

		return retVal;
	}




		
        
			layout( ogre_t1 ) uniform texture2DArray ltcMatrix;
            layout( ogre_s1 ) uniform sampler ltcSampler;
        
		
		
	







void main()
{
    
	
	
	

	
		PixelData pixelData;

		
	
		
            ushort materialId	= worldMaterialIdx[inPs.drawId].x & 0x1FFu;
            #define material materialArray[materialId]
		
	

		
	
				ushort texIndex_diffuseIdx			= material.indices0_3.x & 0x0000FFFFu;
		
		
		
		
		
	

		
	
				ushort texIndex_normalIdx			= material.indices0_3.x >> 16u;
				ushort texIndex_specularIdx			= material.indices0_3.y & 0x0000FFFFu;
				ushort texIndex_roughnessIdx		= material.indices0_3.y >> 16u;
		
		
		
		
		
		
	

		
		

		
	


		
	/// Sample detail maps and weight them against the weight map in the next foreach loop.
	


		
			
	/// DIFFUSE MAP
	
		pixelData.diffuse = SampleDiffuse( textureMaps0,
										   samplerState3,
										   UV_DIFFUSE( inPs.uv0.xy ),
										   texIndex_diffuseIdx );
	

	/// Blend the detail diffuse maps with the main diffuse.
	

	/// Apply the material's diffuse over the textures
	pixelData.diffuse.xyz *= midf3_c( material.kD.xyz );
	

	

		

		
	/// SPECUlAR MAP
	pixelData.specular.xyz = midf3_c( material.kS.xyz );
	
		pixelData.F0 = float_fresnel_c( material.F0.x );
		
			pixelData.specular.xyz *= SampleSpecular( textureMaps0,
													  samplerState3,
													  UV_SPECULAR( inPs.uv0.xy ),
													  texIndex_specularIdx ).xyz;
		
		
	
	

		
		
	/// ROUGHNESS MAP
	pixelData.perceptualRoughness = midf_c( material.kS.w );
	
		pixelData.perceptualRoughness *=
			SampleRoughness( textureMaps2,
							 samplerState3,
							 UV_ROUGHNESS( inPs.uv0.xy ),
							 texIndex_roughnessIdx ).x;
	



	
		pixelData.roughness = max( pixelData.perceptualRoughness * pixelData.perceptualRoughness, _h( 0.001f ) );
	




		

		
			
	
		//Normal mapping.
		pixelData.geomNormal = normalize( inPs.normal ) ;
		midf3 vTangent		= normalize( inPs.tangent );

		
			
		

		//Get the TBN matrix
		midf3 vBinormal	= normalize( cross( pixelData.geomNormal, vTangent ) * inPs.biNormalReflection );
		midf3x3 TBN		= buildMidf3x3( vTangent, vBinormal, pixelData.geomNormal );

		
			pixelData.normal = getTSNormal( textureMaps1,
											samplerState3,
											UV_NORMAL( inPs.uv0.xy ),
											texIndex_normalIdx );
		
		
	

			
	/// If there is no normal map, the first iteration must
	/// initialize pixelData.normal instead of try to merge with it.
	
		
		
	

	

	

	/// Blend the detail normal maps with the main normal.
	
	


			

			

			
				pixelData.normal = normalize( mul( TBN, pixelData.normal ) );
			

			

	
	midf fShadow = _h( 1.0 );
	
		midf fShadowBlend = _h( 1.0 );
	
	
		if( inPs.depth <= passBuf.pssmSplitPoints0 )
		{
			fShadow = getShadow( hlms_shadowmap0, shadowSampler, 
								 inPs_posL0,
								 passBuf.shadowRcv[0].invShadowMapSize
								 hlms_shadowmap0_uv_param );
			
				if( inPs.depth > passBuf.pssmBlendPoints0 )
				{
					fShadowBlend = getShadow( hlms_shadowmap1, shadowSampler, 
											  inPs_posL1,
											  passBuf.shadowRcv[1].invShadowMapSize
											  hlms_shadowmap1_uv_param );
					fShadow = lerp(
						fShadow, fShadowBlend,
						midf_c( ( inPs.depth - passBuf.pssmBlendPoints0 ) /
								( passBuf.pssmSplitPoints0 -
								  passBuf.pssmBlendPoints0 ) ) );
				}
			
			
		}
		
		else if( inPs.depth <= passBuf.pssmSplitPoints1 )
		{
			fShadow = getShadow( hlms_shadowmap1, shadowSampler, 
								 inPs_posL1,
								 passBuf.shadowRcv[1].invShadowMapSize
								 hlms_shadowmap1_uv_param );
			
				if( inPs.depth > passBuf.pssmBlendPoints1 )
				{
					fShadowBlend = getShadow( hlms_shadowmap2, shadowSampler, 
											  inPs_posL2,
											  passBuf.shadowRcv[2].invShadowMapSize
											  hlms_shadowmap2_uv_param );
					fShadow = lerp(
						fShadow, fShadowBlend,
						midf_c( ( inPs.depth - passBuf.pssmBlendPoints1 ) /
								( passBuf.pssmSplitPoints1 -
								  passBuf.pssmBlendPoints1 ) ) );
				}
			
			
		}
		else if( inPs.depth <= passBuf.pssmSplitPoints2 )
		{
			fShadow = getShadow( hlms_shadowmap2, shadowSampler, 
								 inPs_posL2,
								 passBuf.shadowRcv[2].invShadowMapSize
								 hlms_shadowmap2_uv_param );
			
				if( inPs.depth > passBuf.pssmFadePoint )
				{
					fShadow = lerp( fShadow, _h( 1.0 ),
									midf_c( ( inPs.depth - passBuf.pssmFadePoint ) /
											( passBuf.pssmSplitPoints2 -
											  passBuf.pssmFadePoint ) ) );
				}
			
			
		}
	



		

		
			
	//Everything's in Camera space
	
		
			pixelData.viewDir	= midf3_c( normalize( -inPs.pos ) );
		
		pixelData.NdotV		= saturate( dot( pixelData.normal, pixelData.viewDir ) );
	

	
		midf3 finalColour = midf3_c(0, 0, 0);
	

	
		float3 lightDir;
		float fDistance;
		midf3 tmpColour;
		midf spotCosAngle;
	

	

	
		pixelData.reflDir = _h( 2.0 ) * dot( pixelData.viewDir, pixelData.normal ) * pixelData.normal -
							pixelData.viewDir;
	

	
		midf ambientWD =
			dot( midf3_c( passBuf.ambientHemisphereDir.xyz ), pixelData.normal ) * _h( 0.5 ) + _h( 0.5 );
		midf ambientWS =
			dot( midf3_c( passBuf.ambientHemisphereDir.xyz ), pixelData.reflDir ) * _h( 0.5 ) + _h( 0.5 );
	


			

			
				
	
		
			finalColour += BRDF( midf3_c( light0Buf.lights[0].position.xyz ),
								 midf3_c( light0Buf.lights[0].diffuse.xyz ),
								 midf3_c( light0Buf.lights[0].specular ), pixelData ) * fShadow;
	
	

	
		
	

			

			

	


			

	



			
			

			

			
				pixelData.envColourS = midf3_c( 0, 0, 0 );
				pixelData.envColourD = midf3_c( 0, 0, 0 );

				
			

			
			

			
			

			
	


			

			

			

			
	

	
		
				pixelData.envColourS += lerp( midf3_c( passBuf.ambientLowerHemi.xyz ),
											  midf3_c( passBuf.ambientUpperHemi.xyz ), ambientWD );
				pixelData.envColourD += lerp( midf3_c( passBuf.ambientLowerHemi.xyz ),
											  midf3_c( passBuf.ambientUpperHemi.xyz ), ambientWS );
		
	

	


			
				
	//Normally we'd use VdotH. However:
	//	H = normalize(lightDir + viewDir)
	//since:
	//	lightDir = pixelData.reflDir
	//then:
	//	H = geomNormal
	//Thus H = N, and therefore we use VdotN (NdotV)
	//float VdotH = saturate( dot( pixelData.viewDir, normalize( pixelData.reflDir + pixelData.viewDir ) ) );
	float_fresnel fresnelS = pixelData.F0 + pow( _h( 1.0 ) - pixelData.NdotV, _h( 5.0 ) ) * (max( make_float_fresnel( _h( 1.0 ) - pixelData.roughness ), pixelData.F0 ) - pixelData.F0);

	
		#define brdfLUT ltcMatrix
		midf2 envBRDF = OGRE_SampleArray2DF16( brdfLUT, ltcSampler,
											   float2( pixelData.NdotV,
													   1.0 - pixelData.perceptualRoughness ), 2 ).xy;
	

	
		midf fresnelD = _h( 1.0f ) - fresnelS;
	

	midf3 Rd = pixelData.envColourD * pixelData.diffuse.xyz * fresnelD;
	midf3 Rs = pixelData.envColourS * pixelData.specular.xyz * ( fresnelS * envBRDF.x + envBRDF.y );

	

	finalColour += Rd + Rs;

			

			

			
				const float distToCamera = length( inPs.pos.xyz );
				const midf luminance = dot( finalColour.xyz,
											midf3_c( _h( 0.212655 ), _h( 0.715158 ), _h( 0.072187 ) ) );
				const midf lumFogWeight = max( exp2( atmoSettings.fogBreakFalloff * luminance +
													 atmoSettings.fogBreakMinBrightness ),
											   _h( 0.0 ) );
				midf fogWeight = midf_c( exp2( -distToCamera * atmoSettings.fogDensity ) );
				fogWeight = lerp( _h( 1.0 ), fogWeight, lumFogWeight );
				finalColour.xyz = lerp( inPs.fog.xyz, finalColour.xyz, fogWeight );
			
		///!hlms_prepass

	///!hlms_normal || hlms_qtangent

	
		
			
				
					outPs_colour0.xyz	= finalColour;
				

				
					outPs_colour0.w		= _h( 1.0 );
				

							
				
			
		
	

	
}
///hlms_shadowcaster
